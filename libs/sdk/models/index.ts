/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type Guid, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

export interface AvailabilityResponse extends Parsable {
    /**
     * The available property
     */
    available?: boolean | null;
}
export interface BaseDateFieldProps extends BaseFieldProps, Parsable {
    /**
     * The max property
     */
    max?: number | null;
    /**
     * The min property
     */
    min?: number | null;
}
export interface BaseFieldProps extends Parsable {
    /**
     * The readonly property
     */
    readonly?: boolean | null;
    /**
     * The required property
     */
    required?: boolean | null;
    /**
     * The span property
     */
    span?: number | null;
}
export interface BaseFormItemDefinition extends Parsable {
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The path property
     */
    path?: string | null;
    /**
     * The relevance property
     */
    relevance?: RelevanceDefinition | null;
}
export interface BooleanFieldMeta extends BaseFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: boolean | null;
    /**
     * The type property
     */
    type?: BooleanFieldMeta_type | null;
}
export type BooleanFieldMeta_type = (typeof BooleanFieldMeta_typeObject)[keyof typeof BooleanFieldMeta_typeObject];
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {AvailabilityResponse}
 */
// @ts-ignore
export function createAvailabilityResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAvailabilityResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseDateFieldProps}
 */
// @ts-ignore
export function createBaseDateFieldPropsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseDateFieldProps;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseFieldProps}
 */
// @ts-ignore
export function createBaseFieldPropsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseFieldProps;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BaseFormItemDefinition}
 */
// @ts-ignore
export function createBaseFormItemDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBaseFormItemDefinition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BooleanFieldMeta}
 */
// @ts-ignore
export function createBooleanFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoBooleanFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Dataset}
 */
// @ts-ignore
export function createDatasetFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDataset;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetInsert_data}
 */
// @ts-ignore
export function createDatasetInsert_dataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetInsert_data;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetInsert}
 */
// @ts-ignore
export function createDatasetInsertFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetInsert;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetItem}
 */
// @ts-ignore
export function createDatasetItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetLookup}
 */
// @ts-ignore
export function createDatasetLookupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetLookup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetParentRef}
 */
// @ts-ignore
export function createDatasetParentRefFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetParentRef;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExistingDatasetItemUpdate | NewDatasetItem}
 */
// @ts-ignore
export function createDatasetUpdate_data_itemsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetUpdate_data_items;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetUpdate_data}
 */
// @ts-ignore
export function createDatasetUpdate_dataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetUpdate_data;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatasetUpdate}
 */
// @ts-ignore
export function createDatasetUpdateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatasetUpdate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExistingDatasetItemUpdate}
 */
// @ts-ignore
export function createExistingDatasetItemUpdateFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExistingDatasetItemUpdate;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta}
 */
// @ts-ignore
export function createFieldItemMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    const mappingValueNode = parseNode?.getChildNode("type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "boolean":
                    return deserializeIntoBooleanFieldMeta;
                case "date":
                    return deserializeIntoSimpleDateFieldMeta;
                case "date-range":
                    return deserializeIntoRangeDateFieldMeta;
                case "date-time":
                    return deserializeIntoSimpleDateFieldMeta;
                case "float":
                    return deserializeIntoNumberFieldMeta;
                case "geo-point":
                    return deserializeIntoGeoPointFieldMeta;
                case "integer":
                    return deserializeIntoNumberFieldMeta;
                case "multi-date":
                    return deserializeIntoMultiDateFieldMeta;
                case "multi-select":
                    return deserializeIntoSelectFieldMeta;
                case "multiline":
                    return deserializeIntoTextFieldMeta;
                case "single-select":
                    return deserializeIntoSelectFieldMeta;
                case "text":
                    return deserializeIntoTextFieldMeta;
            }
        }
    }
    return deserializeIntoFieldItemMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator}
 */
// @ts-ignore
export function createFormItemDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    const mappingValueNode = parseNode?.getChildNode("type");
    if (mappingValueNode) {
        const mappingValue = mappingValueNode.getStringValue();
        if (mappingValue) {
            switch (mappingValue) {
                case "field":
                    return deserializeIntoFormItemField;
                case "group":
                    return deserializeIntoFormItemGroup;
                case "image":
                    return deserializeIntoFormItemImage;
                case "note":
                    return deserializeIntoFormItemNote;
                case "separator":
                    return deserializeIntoFormItemSeparator;
            }
        }
    }
    return deserializeIntoFormItemDefinition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemField}
 */
// @ts-ignore
export function createFormItemFieldFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormItemField;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemGroup}
 */
// @ts-ignore
export function createFormItemGroupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormItemGroup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemImage}
 */
// @ts-ignore
export function createFormItemImageFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormItemImage;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemNote}
 */
// @ts-ignore
export function createFormItemNoteFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormItemNote;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormItemSeparator}
 */
// @ts-ignore
export function createFormItemSeparatorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormItemSeparator;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormLookup}
 */
// @ts-ignore
export function createFormLookupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormLookup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormVersionDefinition}
 */
// @ts-ignore
export function createFormVersionDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormVersionDefinition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {FormVersionLookup}
 */
// @ts-ignore
export function createFormVersionLookupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoFormVersionLookup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GeoPointFieldMeta}
 */
// @ts-ignore
export function createGeoPointFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGeoPointFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GeoPoint}
 */
// @ts-ignore
export function createGeoPointFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGeoPoint;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImageItemMeta}
 */
// @ts-ignore
export function createImageItemMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImageItemMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {MultiDateFieldMeta}
 */
// @ts-ignore
export function createMultiDateFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoMultiDateFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NewDatasetItem}
 */
// @ts-ignore
export function createNewDatasetItemFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNewDatasetItem;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NoteItemMeta}
 */
// @ts-ignore
export function createNoteItemMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNoteItemMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NumberFieldMeta}
 */
// @ts-ignore
export function createNumberFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNumberFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {NumberRange}
 */
// @ts-ignore
export function createNumberRangeFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoNumberRange;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RangeDateFieldMeta}
 */
// @ts-ignore
export function createRangeDateFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRangeDateFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelevanceCondition}
 */
// @ts-ignore
export function createRelevanceConditionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelevanceCondition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelevanceDefinition}
 */
// @ts-ignore
export function createRelevanceDefinitionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelevanceDefinition;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelevanceLogicExpression_value}
 */
// @ts-ignore
export function createRelevanceLogicExpression_valueFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelevanceLogicExpression_value;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {RelevanceLogicExpression}
 */
// @ts-ignore
export function createRelevanceLogicExpressionFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoRelevanceLogicExpression;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SelectFieldMeta_hardOptions}
 */
// @ts-ignore
export function createSelectFieldMeta_hardOptionsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSelectFieldMeta_hardOptions;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SelectFieldMeta}
 */
// @ts-ignore
export function createSelectFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSelectFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SeparatorItemMeta}
 */
// @ts-ignore
export function createSeparatorItemMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSeparatorItemMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SimpleDateFieldMeta}
 */
// @ts-ignore
export function createSimpleDateFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSimpleDateFieldMeta;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionLookup}
 */
// @ts-ignore
export function createSubmissionLookupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionLookup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionResponse}
 */
// @ts-ignore
export function createSubmissionResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SubmissionVersionLookup}
 */
// @ts-ignore
export function createSubmissionVersionLookupFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoSubmissionVersionLookup;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {TextFieldMeta}
 */
// @ts-ignore
export function createTextFieldMetaFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoTextFieldMeta;
}
export interface Dataset extends Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The items property
     */
    items?: DatasetItem[] | null;
    /**
     * The key property
     */
    key?: string | null;
    /**
     * The parent property
     */
    parent?: DatasetParentRef | null;
    /**
     * The parentId property
     */
    parentId?: Guid | null;
    /**
     * The title property
     */
    title?: string | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface DatasetInsert extends Parsable {
    /**
     * The data property
     */
    data?: DatasetInsert_data | null;
    /**
     * The isNew property
     */
    isNew?: DatasetInsert_isNew | null;
}
export interface DatasetInsert_data extends Parsable {
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The items property
     */
    items?: NewDatasetItem[] | null;
    /**
     * The key property
     */
    key?: string | null;
    /**
     * The parentId property
     */
    parentId?: string | null;
    /**
     * The title property
     */
    title?: string | null;
}
export type DatasetInsert_isNew = (typeof DatasetInsert_isNewObject)[keyof typeof DatasetInsert_isNewObject];
export interface DatasetItem extends Parsable {
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The ordinal property
     */
    ordinal?: number | null;
    /**
     * The parentValue property
     */
    parentValue?: string | null;
    /**
     * The value property
     */
    value?: string | null;
}
export interface DatasetLookup extends Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The itemCount property
     */
    itemCount?: number | null;
    /**
     * The title property
     */
    title?: string | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface DatasetParentRef extends Parsable {
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The key property
     */
    key?: string | null;
    /**
     * The title property
     */
    title?: string | null;
}
export interface DatasetUpdate extends Parsable {
    /**
     * The data property
     */
    data?: DatasetUpdate_data | null;
    /**
     * The isNew property
     */
    isNew?: DatasetUpdate_isNew | null;
}
export interface DatasetUpdate_data extends Parsable {
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The items property
     */
    items?: (ExistingDatasetItemUpdate | NewDatasetItem)[] | null;
    /**
     * The key property
     */
    key?: string | null;
    /**
     * The parentId property
     */
    parentId?: string | null;
    /**
     * The title property
     */
    title?: string | null;
}
export type DatasetUpdate_data_items = ExistingDatasetItemUpdate | NewDatasetItem;
export type DatasetUpdate_isNew = (typeof DatasetUpdate_isNewObject)[keyof typeof DatasetUpdate_isNewObject];
/**
 * The deserialization information for the current model
 * @param AvailabilityResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAvailabilityResponse(availabilityResponse: Partial<AvailabilityResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "available": n => { availabilityResponse.available = n.getBooleanValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BaseDateFieldProps The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBaseDateFieldProps(baseDateFieldProps: Partial<BaseDateFieldProps> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(baseDateFieldProps),
        "max": n => { baseDateFieldProps.max = n.getNumberValue(); },
        "min": n => { baseDateFieldProps.min = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BaseFieldProps The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBaseFieldProps(baseFieldProps: Partial<BaseFieldProps> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "readonly": n => { baseFieldProps.readonly = n.getBooleanValue(); },
        "required": n => { baseFieldProps.required = n.getBooleanValue(); },
        "span": n => { baseFieldProps.span = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param BaseFormItemDefinition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBaseFormItemDefinition(baseFormItemDefinition: Partial<BaseFormItemDefinition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { baseFormItemDefinition.id = n.getGuidValue(); },
        "path": n => { baseFormItemDefinition.path = n.getStringValue(); },
        "relevance": n => { baseFormItemDefinition.relevance = n.getObjectValue<RelevanceDefinition>(createRelevanceDefinitionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param BooleanFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoBooleanFieldMeta(booleanFieldMeta: Partial<BooleanFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(booleanFieldMeta),
        "defaultValue": n => { booleanFieldMeta.defaultValue = n.getBooleanValue(); },
        "type": n => { booleanFieldMeta.type = n.getEnumValue<BooleanFieldMeta_type>(BooleanFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param Dataset The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDataset(dataset: Partial<Dataset> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { dataset.createdAt = n.getDateValue(); },
        "description": n => { dataset.description = n.getStringValue(); },
        "id": n => { dataset.id = n.getGuidValue(); },
        "items": n => { dataset.items = n.getCollectionOfObjectValues<DatasetItem>(createDatasetItemFromDiscriminatorValue); },
        "key": n => { dataset.key = n.getStringValue(); },
        "parent": n => { dataset.parent = n.getObjectValue<DatasetParentRef>(createDatasetParentRefFromDiscriminatorValue); },
        "parentId": n => { dataset.parentId = n.getGuidValue(); },
        "title": n => { dataset.title = n.getStringValue(); },
        "updatedAt": n => { dataset.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetInsert The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetInsert(datasetInsert: Partial<DatasetInsert> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "data": n => { datasetInsert.data = n.getObjectValue<DatasetInsert_data>(createDatasetInsert_dataFromDiscriminatorValue); },
        "isNew": n => { datasetInsert.isNew = n.getEnumValue<DatasetInsert_isNew>(DatasetInsert_isNewObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetInsert_data The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetInsert_data(datasetInsert_data: Partial<DatasetInsert_data> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "description": n => { datasetInsert_data.description = n.getStringValue(); },
        "items": n => { datasetInsert_data.items = n.getCollectionOfObjectValues<NewDatasetItem>(createNewDatasetItemFromDiscriminatorValue); },
        "key": n => { datasetInsert_data.key = n.getStringValue(); },
        "parentId": n => { datasetInsert_data.parentId = n.getStringValue(); },
        "title": n => { datasetInsert_data.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetItem The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetItem(datasetItem: Partial<DatasetItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { datasetItem.id = n.getGuidValue(); },
        "label": n => { datasetItem.label = n.getStringValue(); },
        "ordinal": n => { datasetItem.ordinal = n.getNumberValue(); },
        "parentValue": n => { datasetItem.parentValue = n.getStringValue(); },
        "value": n => { datasetItem.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetLookup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetLookup(datasetLookup: Partial<DatasetLookup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { datasetLookup.createdAt = n.getDateValue(); },
        "description": n => { datasetLookup.description = n.getStringValue(); },
        "id": n => { datasetLookup.id = n.getGuidValue(); },
        "itemCount": n => { datasetLookup.itemCount = n.getNumberValue(); },
        "title": n => { datasetLookup.title = n.getStringValue(); },
        "updatedAt": n => { datasetLookup.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetParentRef The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetParentRef(datasetParentRef: Partial<DatasetParentRef> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "description": n => { datasetParentRef.description = n.getStringValue(); },
        "key": n => { datasetParentRef.key = n.getStringValue(); },
        "title": n => { datasetParentRef.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetUpdate The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetUpdate(datasetUpdate: Partial<DatasetUpdate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "data": n => { datasetUpdate.data = n.getObjectValue<DatasetUpdate_data>(createDatasetUpdate_dataFromDiscriminatorValue); },
        "isNew": n => { datasetUpdate.isNew = n.getEnumValue<DatasetUpdate_isNew>(DatasetUpdate_isNewObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetUpdate_data The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetUpdate_data(datasetUpdate_data: Partial<DatasetUpdate_data> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "description": n => { datasetUpdate_data.description = n.getStringValue(); },
        "id": n => { datasetUpdate_data.id = n.getGuidValue(); },
        "items": n => { datasetUpdate_data.items = n.getCollectionOfObjectValues<ExistingDatasetItemUpdate>(createExistingDatasetItemUpdateFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<NewDatasetItem>(createNewDatasetItemFromDiscriminatorValue); },
        "key": n => { datasetUpdate_data.key = n.getStringValue(); },
        "parentId": n => { datasetUpdate_data.parentId = n.getStringValue(); },
        "title": n => { datasetUpdate_data.title = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatasetUpdate_data_items The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatasetUpdate_data_items(datasetUpdate_data_items: Partial<ExistingDatasetItemUpdate | NewDatasetItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoExistingDatasetItemUpdate(datasetUpdate_data_items as ExistingDatasetItemUpdate),
        ...deserializeIntoNewDatasetItem(datasetUpdate_data_items as NewDatasetItem),
    }
}
/**
 * The deserialization information for the current model
 * @param ExistingDatasetItemUpdate The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExistingDatasetItemUpdate(existingDatasetItemUpdate: Partial<ExistingDatasetItemUpdate> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { existingDatasetItemUpdate.id = n.getGuidValue(); },
        "isNew": n => { existingDatasetItemUpdate.isNew = n.getEnumValue<ExistingDatasetItemUpdate_isNew>(ExistingDatasetItemUpdate_isNewObject); },
        "label": n => { existingDatasetItemUpdate.label = n.getStringValue(); },
        "ordinal": n => { existingDatasetItemUpdate.ordinal = n.getNumberValue(); },
        "parentValue": n => { existingDatasetItemUpdate.parentValue = n.getStringValue(); },
        "value": n => { existingDatasetItemUpdate.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FieldItemMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFieldItemMeta(fieldItemMeta: Partial<BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBooleanFieldMeta(fieldItemMeta as BooleanFieldMeta),
        ...deserializeIntoGeoPointFieldMeta(fieldItemMeta as GeoPointFieldMeta),
        ...deserializeIntoMultiDateFieldMeta(fieldItemMeta as MultiDateFieldMeta),
        ...deserializeIntoNumberFieldMeta(fieldItemMeta as NumberFieldMeta),
        ...deserializeIntoRangeDateFieldMeta(fieldItemMeta as RangeDateFieldMeta),
        ...deserializeIntoSelectFieldMeta(fieldItemMeta as SelectFieldMeta),
        ...deserializeIntoSimpleDateFieldMeta(fieldItemMeta as SimpleDateFieldMeta),
        ...deserializeIntoTextFieldMeta(fieldItemMeta as TextFieldMeta),
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemDefinition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemDefinition(formItemDefinition: Partial<FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoFormItemField(formItemDefinition as FormItemField),
        ...deserializeIntoFormItemGroup(formItemDefinition as FormItemGroup),
        ...deserializeIntoFormItemImage(formItemDefinition as FormItemImage),
        ...deserializeIntoFormItemNote(formItemDefinition as FormItemNote),
        ...deserializeIntoFormItemSeparator(formItemDefinition as FormItemSeparator),
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemField The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemField(formItemField: Partial<FormItemField> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFormItemDefinition(formItemField),
        "description": n => { formItemField.description = n.getStringValue(); },
        "meta": n => { formItemField.meta = n.getObjectValue<BooleanFieldMeta>(createBooleanFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<GeoPointFieldMeta>(createGeoPointFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<MultiDateFieldMeta>(createMultiDateFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<NumberFieldMeta>(createNumberFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<RangeDateFieldMeta>(createRangeDateFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<SelectFieldMeta>(createSelectFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<SimpleDateFieldMeta>(createSimpleDateFieldMetaFromDiscriminatorValue) ?? n.getObjectValue<TextFieldMeta>(createTextFieldMetaFromDiscriminatorValue); },
        "title": n => { formItemField.title = n.getStringValue(); },
        "type": n => { formItemField.type = n.getEnumValue<FormItemField_type>(FormItemField_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemGroup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemGroup(formItemGroup: Partial<FormItemGroup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFormItemDefinition(formItemGroup),
        "children": n => { formItemGroup.children = n.getCollectionOfObjectValues<FormItemField>(createFormItemFieldFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemGroup>(createFormItemGroupFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemImage>(createFormItemImageFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemNote>(createFormItemNoteFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemSeparator>(createFormItemSeparatorFromDiscriminatorValue); },
        "type": n => { formItemGroup.type = n.getEnumValue<FormItemGroup_type>(FormItemGroup_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemImage The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemImage(formItemImage: Partial<FormItemImage> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFormItemDefinition(formItemImage),
        "meta": n => { formItemImage.meta = n.getObjectValue<ImageItemMeta>(createImageItemMetaFromDiscriminatorValue); },
        "type": n => { formItemImage.type = n.getEnumValue<FormItemImage_type>(FormItemImage_typeObject); },
        "url": n => { formItemImage.url = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemNote The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemNote(formItemNote: Partial<FormItemNote> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFormItemDefinition(formItemNote),
        "meta": n => { formItemNote.meta = n.getObjectValue<NoteItemMeta>(createNoteItemMetaFromDiscriminatorValue); },
        "title": n => { formItemNote.title = n.getStringValue(); },
        "type": n => { formItemNote.type = n.getEnumValue<FormItemNote_type>(FormItemNote_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormItemSeparator The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormItemSeparator(formItemSeparator: Partial<FormItemSeparator> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFormItemDefinition(formItemSeparator),
        "meta": n => { formItemSeparator.meta = n.getObjectValue<SeparatorItemMeta>(createSeparatorItemMetaFromDiscriminatorValue); },
        "type": n => { formItemSeparator.type = n.getEnumValue<FormItemSeparator_type>(FormItemSeparator_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormLookup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormLookup(formLookup: Partial<FormLookup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { formLookup.createdAt = n.getDateValue(); },
        "createdBy": n => { formLookup.createdBy = n.getStringValue(); },
        "description": n => { formLookup.description = n.getStringValue(); },
        "label": n => { formLookup.label = n.getStringValue(); },
        "logo": n => { formLookup.logo = n.getStringValue(); },
        "slug": n => { formLookup.slug = n.getStringValue(); },
        "updatedAt": n => { formLookup.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormVersionDefinition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormVersionDefinition(formVersionDefinition: Partial<FormVersionDefinition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "id": n => { formVersionDefinition.id = n.getGuidValue(); },
        "items": n => { formVersionDefinition.items = n.getCollectionOfObjectValues<FormItemField>(createFormItemFieldFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemGroup>(createFormItemGroupFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemImage>(createFormItemImageFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemNote>(createFormItemNoteFromDiscriminatorValue) ?? n.getCollectionOfObjectValues<FormItemSeparator>(createFormItemSeparatorFromDiscriminatorValue); },
        "parentId": n => { formVersionDefinition.parentId = n.getGuidValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param FormVersionLookup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFormVersionLookup(formVersionLookup: Partial<FormVersionLookup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { formVersionLookup.createdAt = n.getDateValue(); },
        "form": n => { formVersionLookup.form = n.getStringValue(); },
        "id": n => { formVersionLookup.id = n.getGuidValue(); },
        "isCurrent": n => { formVersionLookup.isCurrent = n.getBooleanValue(); },
        "label": n => { formVersionLookup.label = n.getStringValue(); },
        "parentId": n => { formVersionLookup.parentId = n.getStringValue(); },
        "updatedAt": n => { formVersionLookup.updatedAt = n.getDateValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param GeoPoint The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGeoPoint(geoPoint: Partial<GeoPoint> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "lat": n => { geoPoint.lat = n.getNumberValue(); },
        "long": n => { geoPoint.long = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param GeoPointFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGeoPointFieldMeta(geoPointFieldMeta: Partial<GeoPointFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(geoPointFieldMeta),
        "defaultValue": n => { geoPointFieldMeta.defaultValue = n.getObjectValue<GeoPoint>(createGeoPointFromDiscriminatorValue); },
        "type": n => { geoPointFieldMeta.type = n.getEnumValue<GeoPointFieldMeta_type>(GeoPointFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param ImageItemMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoImageItemMeta(imageItemMeta: Partial<ImageItemMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "aspectRatio": n => { imageItemMeta.aspectRatio = n.getNumberValue(); },
        "caption": n => { imageItemMeta.caption = n.getStringValue(); },
        "height": n => { imageItemMeta.height = n.getNumberValue(); },
        "width": n => { imageItemMeta.width = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param MultiDateFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoMultiDateFieldMeta(multiDateFieldMeta: Partial<MultiDateFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseDateFieldProps(multiDateFieldMeta),
        "defaultValue": n => { multiDateFieldMeta.defaultValue = n.getCollectionOfPrimitiveValues<number>(); },
        "maxSelection": n => { multiDateFieldMeta.maxSelection = n.getNumberValue(); },
        "minSelection": n => { multiDateFieldMeta.minSelection = n.getNumberValue(); },
        "type": n => { multiDateFieldMeta.type = n.getEnumValue<MultiDateFieldMeta_type>(MultiDateFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param NewDatasetItem The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNewDatasetItem(newDatasetItem: Partial<NewDatasetItem> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "isNew": n => { newDatasetItem.isNew = n.getEnumValue<NewDatasetItem_isNew>(NewDatasetItem_isNewObject); },
        "label": n => { newDatasetItem.label = n.getStringValue(); },
        "ordinal": n => { newDatasetItem.ordinal = n.getNumberValue(); },
        "parentValue": n => { newDatasetItem.parentValue = n.getStringValue(); },
        "value": n => { newDatasetItem.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param NoteItemMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNoteItemMeta(noteItemMeta: Partial<NoteItemMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "fontSize": n => { noteItemMeta.fontSize = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param NumberFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNumberFieldMeta(numberFieldMeta: Partial<NumberFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(numberFieldMeta),
        "defaultValue": n => { numberFieldMeta.defaultValue = n.getNumberValue(); },
        "max": n => { numberFieldMeta.max = n.getNumberValue(); },
        "min": n => { numberFieldMeta.min = n.getNumberValue(); },
        "type": n => { numberFieldMeta.type = n.getEnumValue<NumberFieldMeta_type>(NumberFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param NumberRange The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoNumberRange(numberRange: Partial<NumberRange> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "end": n => { numberRange.end = n.getNumberValue(); },
        "start": n => { numberRange.start = n.getNumberValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param RangeDateFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRangeDateFieldMeta(rangeDateFieldMeta: Partial<RangeDateFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseDateFieldProps(rangeDateFieldMeta),
        "defaultValue": n => { rangeDateFieldMeta.defaultValue = n.getObjectValue<NumberRange>(createNumberRangeFromDiscriminatorValue); },
        "type": n => { rangeDateFieldMeta.type = n.getEnumValue<RangeDateFieldMeta_type>(RangeDateFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelevanceCondition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelevanceCondition(relevanceCondition: Partial<RelevanceCondition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "expressions": n => { relevanceCondition.expressions = n.getCollectionOfObjectValues<RelevanceLogicExpression>(createRelevanceLogicExpressionFromDiscriminatorValue); },
        "operator": n => { relevanceCondition.operator = n.getEnumValue<RelevanceCondition_operator>(RelevanceCondition_operatorObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelevanceDefinition The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelevanceDefinition(relevanceDefinition: Partial<RelevanceDefinition> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "enabled": n => { relevanceDefinition.enabled = n.getBooleanValue(); },
        "logic": n => { relevanceDefinition.logic = n.getCollectionOfObjectValues<RelevanceCondition>(createRelevanceConditionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelevanceLogicExpression The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelevanceLogicExpression(relevanceLogicExpression: Partial<RelevanceLogicExpression> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "field": n => { relevanceLogicExpression.field = n.getStringValue(); },
        "operator": n => { relevanceLogicExpression.operator = n.getEnumValue<RelevanceLogicExpressionOperator>(RelevanceLogicExpressionOperatorObject); },
        "value": n => { relevanceLogicExpression.value = n.getObjectValue<RelevanceLogicExpression_value>(createRelevanceLogicExpression_valueFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param RelevanceLogicExpression_value The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoRelevanceLogicExpression_value(relevanceLogicExpression_value: Partial<RelevanceLogicExpression_value> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param SelectFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSelectFieldMeta(selectFieldMeta: Partial<SelectFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(selectFieldMeta),
        "defaultValue": n => { selectFieldMeta.defaultValue = n.getStringValue(); },
        "hardOptions": n => { selectFieldMeta.hardOptions = n.getCollectionOfObjectValues<SelectFieldMeta_hardOptions>(createSelectFieldMeta_hardOptionsFromDiscriminatorValue); },
        "optionSourceRef": n => { selectFieldMeta.optionSourceRef = n.getStringValue(); },
        "type": n => { selectFieldMeta.type = n.getEnumValue<SelectFieldMeta_type>(SelectFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param SelectFieldMeta_hardOptions The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSelectFieldMeta_hardOptions(selectFieldMeta_hardOptions: Partial<SelectFieldMeta_hardOptions> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "label": n => { selectFieldMeta_hardOptions.label = n.getStringValue(); },
        "value": n => { selectFieldMeta_hardOptions.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param SeparatorItemMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSeparatorItemMeta(separatorItemMeta: Partial<SeparatorItemMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "orientation": n => { separatorItemMeta.orientation = n.getEnumValue<SeparatorItemMeta_orientation>(SeparatorItemMeta_orientationObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param SimpleDateFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSimpleDateFieldMeta(simpleDateFieldMeta: Partial<SimpleDateFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseDateFieldProps(simpleDateFieldMeta),
        "defaultValue": n => { simpleDateFieldMeta.defaultValue = n.getNumberValue(); },
        "type": n => { simpleDateFieldMeta.type = n.getEnumValue<SimpleDateFieldMeta_type>(SimpleDateFieldMeta_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param SubmissionLookup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSubmissionLookup(submissionLookup: Partial<SubmissionLookup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "form": n => { submissionLookup.form = n.getStringValue(); },
        "formVersion": n => { submissionLookup.formVersion = n.getGuidValue(); },
        "index": n => { submissionLookup.index = n.getNumberValue(); },
        "recordedAt": n => { submissionLookup.recordedAt = n.getDateValue(); },
        "versions": n => { submissionLookup.versions = n.getCollectionOfObjectValues<SubmissionVersionLookup>(createSubmissionVersionLookupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param SubmissionResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSubmissionResponse(submissionResponse: Partial<SubmissionResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "fieldId": n => { submissionResponse.fieldId = n.getGuidValue(); },
        "form": n => { submissionResponse.form = n.getStringValue(); },
        "formVersion": n => { submissionResponse.formVersion = n.getGuidValue(); },
        "submissionIndex": n => { submissionResponse.submissionIndex = n.getNumberValue(); },
        "submissionVersionId": n => { submissionResponse.submissionVersionId = n.getGuidValue(); },
        "value": n => { submissionResponse.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param SubmissionVersionLookup The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSubmissionVersionLookup(submissionVersionLookup: Partial<SubmissionVersionLookup> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "approvedAt": n => { submissionVersionLookup.approvedAt = n.getDateValue(); },
        "id": n => { submissionVersionLookup.id = n.getGuidValue(); },
        "isCurrent": n => { submissionVersionLookup.isCurrent = n.getBooleanValue(); },
        "recordedAt": n => { submissionVersionLookup.recordedAt = n.getDateValue(); },
        "validationCode": n => { submissionVersionLookup.validationCode = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param TextFieldMeta The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTextFieldMeta(textFieldMeta: Partial<TextFieldMeta> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoBaseFieldProps(textFieldMeta),
        "defaultValue": n => { textFieldMeta.defaultValue = n.getStringValue(); },
        "maxlength": n => { textFieldMeta.maxlength = n.getNumberValue(); },
        "minlength": n => { textFieldMeta.minlength = n.getNumberValue(); },
        "pattern": n => { textFieldMeta.pattern = n.getStringValue(); },
        "type": n => { textFieldMeta.type = n.getEnumValue<TextFieldMeta_type>(TextFieldMeta_typeObject); },
    }
}
export interface ExistingDatasetItemUpdate extends Parsable {
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The isNew property
     */
    isNew?: ExistingDatasetItemUpdate_isNew | null;
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The ordinal property
     */
    ordinal?: number | null;
    /**
     * The parentValue property
     */
    parentValue?: string | null;
    /**
     * The value property
     */
    value?: string | null;
}
export type ExistingDatasetItemUpdate_isNew = (typeof ExistingDatasetItemUpdate_isNewObject)[keyof typeof ExistingDatasetItemUpdate_isNewObject];
export type FieldItemMeta = BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta;
export type FormItemDefinition = FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator;
export interface FormItemField extends BaseFormItemDefinition, Parsable {
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The meta property
     */
    meta?: BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta | null;
    /**
     * The title property
     */
    title?: string | null;
    /**
     * The type property
     */
    type?: FormItemField_type | null;
}
export type FormItemField_type = (typeof FormItemField_typeObject)[keyof typeof FormItemField_typeObject];
export interface FormItemGroup extends BaseFormItemDefinition, Parsable {
    /**
     * The children property
     */
    children?: (FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator)[] | null;
    /**
     * The type property
     */
    type?: FormItemGroup_type | null;
}
export type FormItemGroup_type = (typeof FormItemGroup_typeObject)[keyof typeof FormItemGroup_typeObject];
export interface FormItemImage extends BaseFormItemDefinition, Parsable {
    /**
     * The meta property
     */
    meta?: ImageItemMeta | null;
    /**
     * The type property
     */
    type?: FormItemImage_type | null;
    /**
     * The url property
     */
    url?: string | null;
}
export type FormItemImage_type = (typeof FormItemImage_typeObject)[keyof typeof FormItemImage_typeObject];
export interface FormItemNote extends BaseFormItemDefinition, Parsable {
    /**
     * The meta property
     */
    meta?: NoteItemMeta | null;
    /**
     * The title property
     */
    title?: string | null;
    /**
     * The type property
     */
    type?: FormItemNote_type | null;
}
export type FormItemNote_type = (typeof FormItemNote_typeObject)[keyof typeof FormItemNote_typeObject];
export interface FormItemSeparator extends BaseFormItemDefinition, Parsable {
    /**
     * The meta property
     */
    meta?: SeparatorItemMeta | null;
    /**
     * The type property
     */
    type?: FormItemSeparator_type | null;
}
export type FormItemSeparator_type = (typeof FormItemSeparator_typeObject)[keyof typeof FormItemSeparator_typeObject];
export interface FormLookup extends Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The createdBy property
     */
    createdBy?: string | null;
    /**
     * The description property
     */
    description?: string | null;
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The logo property
     */
    logo?: string | null;
    /**
     * The slug property
     */
    slug?: string | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface FormVersionDefinition extends Parsable {
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The items property
     */
    items?: (FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator)[] | null;
    /**
     * The parentId property
     */
    parentId?: Guid | null;
}
/**
 * Lookup for a form version
 */
export interface FormVersionLookup extends Parsable {
    /**
     * The createdAt property
     */
    createdAt?: Date | null;
    /**
     * The form property
     */
    form?: string | null;
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The isCurrent property
     */
    isCurrent?: boolean | null;
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The parentId property
     */
    parentId?: string | null;
    /**
     * The updatedAt property
     */
    updatedAt?: Date | null;
}
export interface GeoPoint extends Parsable {
    /**
     * The lat property
     */
    lat?: number | null;
    /**
     * The long property
     */
    long?: number | null;
}
export interface GeoPointFieldMeta extends BaseFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: GeoPoint | null;
    /**
     * The type property
     */
    type?: GeoPointFieldMeta_type | null;
}
export type GeoPointFieldMeta_type = (typeof GeoPointFieldMeta_typeObject)[keyof typeof GeoPointFieldMeta_typeObject];
export interface ImageItemMeta extends Parsable {
    /**
     * The aspectRatio property
     */
    aspectRatio?: number | null;
    /**
     * The caption property
     */
    caption?: string | null;
    /**
     * The height property
     */
    height?: number | null;
    /**
     * The width property
     */
    width?: number | null;
}
export interface MultiDateFieldMeta extends BaseDateFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: number[] | null;
    /**
     * The maxSelection property
     */
    maxSelection?: number | null;
    /**
     * The minSelection property
     */
    minSelection?: number | null;
    /**
     * The type property
     */
    type?: MultiDateFieldMeta_type | null;
}
export type MultiDateFieldMeta_type = (typeof MultiDateFieldMeta_typeObject)[keyof typeof MultiDateFieldMeta_typeObject];
export interface NewDatasetItem extends Parsable {
    /**
     * The isNew property
     */
    isNew?: NewDatasetItem_isNew | null;
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The ordinal property
     */
    ordinal?: number | null;
    /**
     * The parentValue property
     */
    parentValue?: string | null;
    /**
     * The value property
     */
    value?: string | null;
}
export type NewDatasetItem_isNew = (typeof NewDatasetItem_isNewObject)[keyof typeof NewDatasetItem_isNewObject];
export interface NoteItemMeta extends Parsable {
    /**
     * The fontSize property
     */
    fontSize?: number | null;
}
export interface NumberFieldMeta extends BaseFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: number | null;
    /**
     * The max property
     */
    max?: number | null;
    /**
     * The min property
     */
    min?: number | null;
    /**
     * The type property
     */
    type?: NumberFieldMeta_type | null;
}
export type NumberFieldMeta_type = (typeof NumberFieldMeta_typeObject)[keyof typeof NumberFieldMeta_typeObject];
export interface NumberRange extends Parsable {
    /**
     * The end property
     */
    end?: number | null;
    /**
     * The start property
     */
    start?: number | null;
}
export interface RangeDateFieldMeta extends BaseDateFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: NumberRange | null;
    /**
     * The type property
     */
    type?: RangeDateFieldMeta_type | null;
}
export type RangeDateFieldMeta_type = (typeof RangeDateFieldMeta_typeObject)[keyof typeof RangeDateFieldMeta_typeObject];
export interface RelevanceCondition extends Parsable {
    /**
     * The expressions property
     */
    expressions?: RelevanceLogicExpression[] | null;
    /**
     * The operator property
     */
    operator?: RelevanceCondition_operator | null;
}
export type RelevanceCondition_operator = (typeof RelevanceCondition_operatorObject)[keyof typeof RelevanceCondition_operatorObject];
export interface RelevanceDefinition extends Parsable {
    /**
     * The enabled property
     */
    enabled?: boolean | null;
    /**
     * The logic property
     */
    logic?: RelevanceCondition[] | null;
}
export interface RelevanceLogicExpression extends Parsable {
    /**
     * The field property
     */
    field?: string | null;
    /**
     * The operator property
     */
    operator?: RelevanceLogicExpressionOperator | null;
    /**
     * The value property
     */
    value?: RelevanceLogicExpression_value | null;
}
export interface RelevanceLogicExpression_value extends AdditionalDataHolder, Parsable {
}
export type RelevanceLogicExpressionOperator = (typeof RelevanceLogicExpressionOperatorObject)[keyof typeof RelevanceLogicExpressionOperatorObject];
export interface SelectFieldMeta extends BaseFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: string | null;
    /**
     * The hardOptions property
     */
    hardOptions?: SelectFieldMeta_hardOptions[] | null;
    /**
     * The optionSourceRef property
     */
    optionSourceRef?: string | null;
    /**
     * The type property
     */
    type?: SelectFieldMeta_type | null;
}
export interface SelectFieldMeta_hardOptions extends Parsable {
    /**
     * The label property
     */
    label?: string | null;
    /**
     * The value property
     */
    value?: string | null;
}
export type SelectFieldMeta_type = (typeof SelectFieldMeta_typeObject)[keyof typeof SelectFieldMeta_typeObject];
export interface SeparatorItemMeta extends Parsable {
    /**
     * The orientation property
     */
    orientation?: SeparatorItemMeta_orientation | null;
}
export type SeparatorItemMeta_orientation = (typeof SeparatorItemMeta_orientationObject)[keyof typeof SeparatorItemMeta_orientationObject];
/**
 * Serializes information the current object
 * @param AvailabilityResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAvailabilityResponse(writer: SerializationWriter, availabilityResponse: Partial<AvailabilityResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!availabilityResponse || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("available", availabilityResponse.available);
}
/**
 * Serializes information the current object
 * @param BaseDateFieldProps The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBaseDateFieldProps(writer: SerializationWriter, baseDateFieldProps: Partial<BaseDateFieldProps> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!baseDateFieldProps || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, baseDateFieldProps, isSerializingDerivedType)
    writer.writeNumberValue("max", baseDateFieldProps.max);
    writer.writeNumberValue("min", baseDateFieldProps.min);
}
/**
 * Serializes information the current object
 * @param BaseFieldProps The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBaseFieldProps(writer: SerializationWriter, baseFieldProps: Partial<BaseFieldProps> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!baseFieldProps || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("readonly", baseFieldProps.readonly);
    writer.writeBooleanValue("required", baseFieldProps.required);
    writer.writeNumberValue("span", baseFieldProps.span);
}
/**
 * Serializes information the current object
 * @param BaseFormItemDefinition The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBaseFormItemDefinition(writer: SerializationWriter, baseFormItemDefinition: Partial<BaseFormItemDefinition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!baseFormItemDefinition || isSerializingDerivedType) { return; }
    writer.writeGuidValue("id", baseFormItemDefinition.id);
    writer.writeStringValue("path", baseFormItemDefinition.path);
    writer.writeObjectValue<RelevanceDefinition>("relevance", baseFormItemDefinition.relevance, serializeRelevanceDefinition);
}
/**
 * Serializes information the current object
 * @param BooleanFieldMeta The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeBooleanFieldMeta(writer: SerializationWriter, booleanFieldMeta: Partial<BooleanFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!booleanFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, booleanFieldMeta, isSerializingDerivedType)
    writer.writeBooleanValue("defaultValue", booleanFieldMeta.defaultValue);
    writer.writeEnumValue<BooleanFieldMeta_type>("type", booleanFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param Dataset The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDataset(writer: SerializationWriter, dataset: Partial<Dataset> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!dataset || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", dataset.createdAt);
    writer.writeStringValue("description", dataset.description);
    writer.writeGuidValue("id", dataset.id);
    writer.writeCollectionOfObjectValues<DatasetItem>("items", dataset.items, serializeDatasetItem);
    writer.writeStringValue("key", dataset.key);
    writer.writeObjectValue<DatasetParentRef>("parent", dataset.parent, serializeDatasetParentRef);
    writer.writeGuidValue("parentId", dataset.parentId);
    writer.writeStringValue("title", dataset.title);
    writer.writeDateValue("updatedAt", dataset.updatedAt);
}
/**
 * Serializes information the current object
 * @param DatasetInsert The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetInsert(writer: SerializationWriter, datasetInsert: Partial<DatasetInsert> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetInsert || isSerializingDerivedType) { return; }
    writer.writeObjectValue<DatasetInsert_data>("data", datasetInsert.data, serializeDatasetInsert_data);
    writer.writeEnumValue<DatasetInsert_isNew>("isNew", datasetInsert.isNew);
}
/**
 * Serializes information the current object
 * @param DatasetInsert_data The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetInsert_data(writer: SerializationWriter, datasetInsert_data: Partial<DatasetInsert_data> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetInsert_data || isSerializingDerivedType) { return; }
    writer.writeStringValue("description", datasetInsert_data.description);
    writer.writeCollectionOfObjectValues<NewDatasetItem>("items", datasetInsert_data.items, serializeNewDatasetItem);
    writer.writeStringValue("key", datasetInsert_data.key);
    writer.writeStringValue("parentId", datasetInsert_data.parentId);
    writer.writeStringValue("title", datasetInsert_data.title);
}
/**
 * Serializes information the current object
 * @param DatasetItem The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetItem(writer: SerializationWriter, datasetItem: Partial<DatasetItem> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetItem || isSerializingDerivedType) { return; }
    writer.writeGuidValue("id", datasetItem.id);
    writer.writeStringValue("label", datasetItem.label);
    writer.writeNumberValue("ordinal", datasetItem.ordinal);
    writer.writeStringValue("parentValue", datasetItem.parentValue);
    writer.writeStringValue("value", datasetItem.value);
}
/**
 * Serializes information the current object
 * @param DatasetLookup The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetLookup(writer: SerializationWriter, datasetLookup: Partial<DatasetLookup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetLookup || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", datasetLookup.createdAt);
    writer.writeStringValue("description", datasetLookup.description);
    writer.writeGuidValue("id", datasetLookup.id);
    writer.writeNumberValue("itemCount", datasetLookup.itemCount);
    writer.writeStringValue("title", datasetLookup.title);
    writer.writeDateValue("updatedAt", datasetLookup.updatedAt);
}
/**
 * Serializes information the current object
 * @param DatasetParentRef The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetParentRef(writer: SerializationWriter, datasetParentRef: Partial<DatasetParentRef> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetParentRef || isSerializingDerivedType) { return; }
    writer.writeStringValue("description", datasetParentRef.description);
    writer.writeStringValue("key", datasetParentRef.key);
    writer.writeStringValue("title", datasetParentRef.title);
}
/**
 * Serializes information the current object
 * @param DatasetUpdate The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetUpdate(writer: SerializationWriter, datasetUpdate: Partial<DatasetUpdate> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetUpdate || isSerializingDerivedType) { return; }
    writer.writeObjectValue<DatasetUpdate_data>("data", datasetUpdate.data, serializeDatasetUpdate_data);
    writer.writeEnumValue<DatasetUpdate_isNew>("isNew", datasetUpdate.isNew);
}
/**
 * Serializes information the current object
 * @param DatasetUpdate_data The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetUpdate_data(writer: SerializationWriter, datasetUpdate_data: Partial<DatasetUpdate_data> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!datasetUpdate_data || isSerializingDerivedType) { return; }
    writer.writeStringValue("description", datasetUpdate_data.description);
    writer.writeGuidValue("id", datasetUpdate_data.id);
    writer.writeCollectionOfObjectValues<ExistingDatasetItemUpdate | NewDatasetItem>("items", datasetUpdate_data.items, serializeDatasetUpdate_data_items);
    writer.writeStringValue("key", datasetUpdate_data.key);
    writer.writeStringValue("parentId", datasetUpdate_data.parentId);
    writer.writeStringValue("title", datasetUpdate_data.title);
}
/**
 * Serializes information the current object
 * @param DatasetUpdate_data_items The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatasetUpdate_data_items(writer: SerializationWriter, datasetUpdate_data_items: Partial<ExistingDatasetItemUpdate | NewDatasetItem> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    serializeExistingDatasetItemUpdate(writer, datasetUpdate_data_items as ExistingDatasetItemUpdate);
    serializeNewDatasetItem(writer, datasetUpdate_data_items as NewDatasetItem);
}
/**
 * Serializes information the current object
 * @param ExistingDatasetItemUpdate The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExistingDatasetItemUpdate(writer: SerializationWriter, existingDatasetItemUpdate: Partial<ExistingDatasetItemUpdate> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!existingDatasetItemUpdate || isSerializingDerivedType) { return; }
    writer.writeGuidValue("id", existingDatasetItemUpdate.id);
    writer.writeEnumValue<ExistingDatasetItemUpdate_isNew>("isNew", existingDatasetItemUpdate.isNew);
    writer.writeStringValue("label", existingDatasetItemUpdate.label);
    writer.writeNumberValue("ordinal", existingDatasetItemUpdate.ordinal);
    writer.writeStringValue("parentValue", existingDatasetItemUpdate.parentValue);
    writer.writeStringValue("value", existingDatasetItemUpdate.value);
}
/**
 * Serializes information the current object
 * @param FieldItemMeta The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFieldItemMeta(writer: SerializationWriter, fieldItemMeta: Partial<BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (fieldItemMeta === undefined || fieldItemMeta === null) return;
    switch (fieldItemMeta.type) {
        case "boolean":
            serializeBooleanFieldMeta(writer, fieldItemMeta as BooleanFieldMeta);
            break;
        case "date":
            serializeSimpleDateFieldMeta(writer, fieldItemMeta as SimpleDateFieldMeta);
            break;
        case "date-range":
            serializeRangeDateFieldMeta(writer, fieldItemMeta as RangeDateFieldMeta);
            break;
        case "date-time":
            serializeSimpleDateFieldMeta(writer, fieldItemMeta as SimpleDateFieldMeta);
            break;
        case "float":
            serializeNumberFieldMeta(writer, fieldItemMeta as NumberFieldMeta);
            break;
        case "geo-point":
            serializeGeoPointFieldMeta(writer, fieldItemMeta as GeoPointFieldMeta);
            break;
        case "integer":
            serializeNumberFieldMeta(writer, fieldItemMeta as NumberFieldMeta);
            break;
        case "multi-date":
            serializeMultiDateFieldMeta(writer, fieldItemMeta as MultiDateFieldMeta);
            break;
        case "multi-select":
            serializeSelectFieldMeta(writer, fieldItemMeta as SelectFieldMeta);
            break;
        case "multiline":
            serializeTextFieldMeta(writer, fieldItemMeta as TextFieldMeta);
            break;
        case "single-select":
            serializeSelectFieldMeta(writer, fieldItemMeta as SelectFieldMeta);
            break;
        case "text":
            serializeTextFieldMeta(writer, fieldItemMeta as TextFieldMeta);
            break;
    }
}
/**
 * Serializes information the current object
 * @param FormItemDefinition The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemDefinition(writer: SerializationWriter, formItemDefinition: Partial<FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (formItemDefinition === undefined || formItemDefinition === null) return;
    switch (formItemDefinition.type) {
        case "field":
            serializeFormItemField(writer, formItemDefinition as FormItemField);
            break;
        case "group":
            serializeFormItemGroup(writer, formItemDefinition as FormItemGroup);
            break;
        case "image":
            serializeFormItemImage(writer, formItemDefinition as FormItemImage);
            break;
        case "note":
            serializeFormItemNote(writer, formItemDefinition as FormItemNote);
            break;
        case "separator":
            serializeFormItemSeparator(writer, formItemDefinition as FormItemSeparator);
            break;
    }
}
/**
 * Serializes information the current object
 * @param FormItemField The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemField(writer: SerializationWriter, formItemField: Partial<FormItemField> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formItemField || isSerializingDerivedType) { return; }
    serializeBaseFormItemDefinition(writer, formItemField, isSerializingDerivedType)
    writer.writeStringValue("description", formItemField.description);
    writer.writeObjectValue<BooleanFieldMeta | GeoPointFieldMeta | MultiDateFieldMeta | NumberFieldMeta | RangeDateFieldMeta | SelectFieldMeta | SimpleDateFieldMeta | TextFieldMeta>("meta", formItemField.meta, serializeFieldItemMeta);
    writer.writeStringValue("title", formItemField.title);
    writer.writeEnumValue<FormItemField_type>("type", formItemField.type);
}
/**
 * Serializes information the current object
 * @param FormItemGroup The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemGroup(writer: SerializationWriter, formItemGroup: Partial<FormItemGroup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formItemGroup || isSerializingDerivedType) { return; }
    serializeBaseFormItemDefinition(writer, formItemGroup, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator>("children", formItemGroup.children, serializeFormItemDefinition);
    writer.writeEnumValue<FormItemGroup_type>("type", formItemGroup.type);
}
/**
 * Serializes information the current object
 * @param FormItemImage The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemImage(writer: SerializationWriter, formItemImage: Partial<FormItemImage> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formItemImage || isSerializingDerivedType) { return; }
    serializeBaseFormItemDefinition(writer, formItemImage, isSerializingDerivedType)
    writer.writeObjectValue<ImageItemMeta>("meta", formItemImage.meta, serializeImageItemMeta);
    writer.writeEnumValue<FormItemImage_type>("type", formItemImage.type);
    writer.writeStringValue("url", formItemImage.url);
}
/**
 * Serializes information the current object
 * @param FormItemNote The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemNote(writer: SerializationWriter, formItemNote: Partial<FormItemNote> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formItemNote || isSerializingDerivedType) { return; }
    serializeBaseFormItemDefinition(writer, formItemNote, isSerializingDerivedType)
    writer.writeObjectValue<NoteItemMeta>("meta", formItemNote.meta, serializeNoteItemMeta);
    writer.writeStringValue("title", formItemNote.title);
    writer.writeEnumValue<FormItemNote_type>("type", formItemNote.type);
}
/**
 * Serializes information the current object
 * @param FormItemSeparator The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormItemSeparator(writer: SerializationWriter, formItemSeparator: Partial<FormItemSeparator> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formItemSeparator || isSerializingDerivedType) { return; }
    serializeBaseFormItemDefinition(writer, formItemSeparator, isSerializingDerivedType)
    writer.writeObjectValue<SeparatorItemMeta>("meta", formItemSeparator.meta, serializeSeparatorItemMeta);
    writer.writeEnumValue<FormItemSeparator_type>("type", formItemSeparator.type);
}
/**
 * Serializes information the current object
 * @param FormLookup The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormLookup(writer: SerializationWriter, formLookup: Partial<FormLookup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formLookup || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", formLookup.createdAt);
    writer.writeStringValue("createdBy", formLookup.createdBy);
    writer.writeStringValue("description", formLookup.description);
    writer.writeStringValue("label", formLookup.label);
    writer.writeStringValue("logo", formLookup.logo);
    writer.writeStringValue("slug", formLookup.slug);
    writer.writeDateValue("updatedAt", formLookup.updatedAt);
}
/**
 * Serializes information the current object
 * @param FormVersionDefinition The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormVersionDefinition(writer: SerializationWriter, formVersionDefinition: Partial<FormVersionDefinition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formVersionDefinition || isSerializingDerivedType) { return; }
    writer.writeGuidValue("id", formVersionDefinition.id);
    writer.writeCollectionOfObjectValues<FormItemField | FormItemGroup | FormItemImage | FormItemNote | FormItemSeparator>("items", formVersionDefinition.items, serializeFormItemDefinition);
    writer.writeGuidValue("parentId", formVersionDefinition.parentId);
}
/**
 * Serializes information the current object
 * @param FormVersionLookup The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFormVersionLookup(writer: SerializationWriter, formVersionLookup: Partial<FormVersionLookup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!formVersionLookup || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", formVersionLookup.createdAt);
    writer.writeStringValue("form", formVersionLookup.form);
    writer.writeGuidValue("id", formVersionLookup.id);
    writer.writeBooleanValue("isCurrent", formVersionLookup.isCurrent);
    writer.writeStringValue("label", formVersionLookup.label);
    writer.writeStringValue("parentId", formVersionLookup.parentId);
    writer.writeDateValue("updatedAt", formVersionLookup.updatedAt);
}
/**
 * Serializes information the current object
 * @param GeoPoint The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGeoPoint(writer: SerializationWriter, geoPoint: Partial<GeoPoint> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!geoPoint || isSerializingDerivedType) { return; }
    writer.writeNumberValue("lat", geoPoint.lat);
    writer.writeNumberValue("long", geoPoint.long);
}
/**
 * Serializes information the current object
 * @param GeoPointFieldMeta The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGeoPointFieldMeta(writer: SerializationWriter, geoPointFieldMeta: Partial<GeoPointFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!geoPointFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, geoPointFieldMeta, isSerializingDerivedType)
    writer.writeObjectValue<GeoPoint>("defaultValue", geoPointFieldMeta.defaultValue, serializeGeoPoint);
    writer.writeEnumValue<GeoPointFieldMeta_type>("type", geoPointFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param ImageItemMeta The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeImageItemMeta(writer: SerializationWriter, imageItemMeta: Partial<ImageItemMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!imageItemMeta || isSerializingDerivedType) { return; }
    writer.writeNumberValue("aspectRatio", imageItemMeta.aspectRatio);
    writer.writeStringValue("caption", imageItemMeta.caption);
    writer.writeNumberValue("height", imageItemMeta.height);
    writer.writeNumberValue("width", imageItemMeta.width);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param MultiDateFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeMultiDateFieldMeta(writer: SerializationWriter, multiDateFieldMeta: Partial<MultiDateFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!multiDateFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseDateFieldProps(writer, multiDateFieldMeta, isSerializingDerivedType)
    writer.writeCollectionOfPrimitiveValues<number>("defaultValue", multiDateFieldMeta.defaultValue);
    writer.writeNumberValue("maxSelection", multiDateFieldMeta.maxSelection);
    writer.writeNumberValue("minSelection", multiDateFieldMeta.minSelection);
    writer.writeEnumValue<MultiDateFieldMeta_type>("type", multiDateFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NewDatasetItem The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNewDatasetItem(writer: SerializationWriter, newDatasetItem: Partial<NewDatasetItem> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!newDatasetItem || isSerializingDerivedType) { return; }
    writer.writeEnumValue<NewDatasetItem_isNew>("isNew", newDatasetItem.isNew);
    writer.writeStringValue("label", newDatasetItem.label);
    writer.writeNumberValue("ordinal", newDatasetItem.ordinal);
    writer.writeStringValue("parentValue", newDatasetItem.parentValue);
    writer.writeStringValue("value", newDatasetItem.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NoteItemMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNoteItemMeta(writer: SerializationWriter, noteItemMeta: Partial<NoteItemMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!noteItemMeta || isSerializingDerivedType) { return; }
    writer.writeNumberValue("fontSize", noteItemMeta.fontSize);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NumberFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNumberFieldMeta(writer: SerializationWriter, numberFieldMeta: Partial<NumberFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!numberFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, numberFieldMeta, isSerializingDerivedType)
    writer.writeNumberValue("defaultValue", numberFieldMeta.defaultValue);
    writer.writeNumberValue("max", numberFieldMeta.max);
    writer.writeNumberValue("min", numberFieldMeta.min);
    writer.writeEnumValue<NumberFieldMeta_type>("type", numberFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param NumberRange The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeNumberRange(writer: SerializationWriter, numberRange: Partial<NumberRange> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!numberRange || isSerializingDerivedType) { return; }
    writer.writeNumberValue("end", numberRange.end);
    writer.writeNumberValue("start", numberRange.start);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RangeDateFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRangeDateFieldMeta(writer: SerializationWriter, rangeDateFieldMeta: Partial<RangeDateFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!rangeDateFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseDateFieldProps(writer, rangeDateFieldMeta, isSerializingDerivedType)
    writer.writeObjectValue<NumberRange>("defaultValue", rangeDateFieldMeta.defaultValue, serializeNumberRange);
    writer.writeEnumValue<RangeDateFieldMeta_type>("type", rangeDateFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelevanceCondition The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelevanceCondition(writer: SerializationWriter, relevanceCondition: Partial<RelevanceCondition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relevanceCondition || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<RelevanceLogicExpression>("expressions", relevanceCondition.expressions, serializeRelevanceLogicExpression);
    writer.writeEnumValue<RelevanceCondition_operator>("operator", relevanceCondition.operator);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelevanceDefinition The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelevanceDefinition(writer: SerializationWriter, relevanceDefinition: Partial<RelevanceDefinition> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relevanceDefinition || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("enabled", relevanceDefinition.enabled);
    writer.writeCollectionOfObjectValues<RelevanceCondition>("logic", relevanceDefinition.logic, serializeRelevanceCondition);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelevanceLogicExpression The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelevanceLogicExpression(writer: SerializationWriter, relevanceLogicExpression: Partial<RelevanceLogicExpression> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relevanceLogicExpression || isSerializingDerivedType) { return; }
    writer.writeStringValue("field", relevanceLogicExpression.field);
    writer.writeEnumValue<RelevanceLogicExpressionOperator>("operator", relevanceLogicExpression.operator);
    writer.writeObjectValue<RelevanceLogicExpression_value>("value", relevanceLogicExpression.value, serializeRelevanceLogicExpression_value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param RelevanceLogicExpression_value The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeRelevanceLogicExpression_value(writer: SerializationWriter, relevanceLogicExpression_value: Partial<RelevanceLogicExpression_value> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!relevanceLogicExpression_value || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(relevanceLogicExpression_value.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SelectFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSelectFieldMeta(writer: SerializationWriter, selectFieldMeta: Partial<SelectFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!selectFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, selectFieldMeta, isSerializingDerivedType)
    writer.writeStringValue("defaultValue", selectFieldMeta.defaultValue);
    writer.writeCollectionOfObjectValues<SelectFieldMeta_hardOptions>("hardOptions", selectFieldMeta.hardOptions, serializeSelectFieldMeta_hardOptions);
    writer.writeStringValue("optionSourceRef", selectFieldMeta.optionSourceRef);
    writer.writeEnumValue<SelectFieldMeta_type>("type", selectFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SelectFieldMeta_hardOptions The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSelectFieldMeta_hardOptions(writer: SerializationWriter, selectFieldMeta_hardOptions: Partial<SelectFieldMeta_hardOptions> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!selectFieldMeta_hardOptions || isSerializingDerivedType) { return; }
    writer.writeStringValue("label", selectFieldMeta_hardOptions.label);
    writer.writeStringValue("value", selectFieldMeta_hardOptions.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SeparatorItemMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSeparatorItemMeta(writer: SerializationWriter, separatorItemMeta: Partial<SeparatorItemMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!separatorItemMeta || isSerializingDerivedType) { return; }
    writer.writeEnumValue<SeparatorItemMeta_orientation>("orientation", separatorItemMeta.orientation);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SimpleDateFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSimpleDateFieldMeta(writer: SerializationWriter, simpleDateFieldMeta: Partial<SimpleDateFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!simpleDateFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseDateFieldProps(writer, simpleDateFieldMeta, isSerializingDerivedType)
    writer.writeNumberValue("defaultValue", simpleDateFieldMeta.defaultValue);
    writer.writeEnumValue<SimpleDateFieldMeta_type>("type", simpleDateFieldMeta.type);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SubmissionLookup The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSubmissionLookup(writer: SerializationWriter, submissionLookup: Partial<SubmissionLookup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!submissionLookup || isSerializingDerivedType) { return; }
    writer.writeStringValue("form", submissionLookup.form);
    writer.writeGuidValue("formVersion", submissionLookup.formVersion);
    writer.writeNumberValue("index", submissionLookup.index);
    writer.writeDateValue("recordedAt", submissionLookup.recordedAt);
    writer.writeCollectionOfObjectValues<SubmissionVersionLookup>("versions", submissionLookup.versions, serializeSubmissionVersionLookup);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SubmissionResponse The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSubmissionResponse(writer: SerializationWriter, submissionResponse: Partial<SubmissionResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!submissionResponse || isSerializingDerivedType) { return; }
    writer.writeGuidValue("fieldId", submissionResponse.fieldId);
    writer.writeStringValue("form", submissionResponse.form);
    writer.writeGuidValue("formVersion", submissionResponse.formVersion);
    writer.writeNumberValue("submissionIndex", submissionResponse.submissionIndex);
    writer.writeGuidValue("submissionVersionId", submissionResponse.submissionVersionId);
    writer.writeStringValue("value", submissionResponse.value);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SubmissionVersionLookup The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSubmissionVersionLookup(writer: SerializationWriter, submissionVersionLookup: Partial<SubmissionVersionLookup> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!submissionVersionLookup || isSerializingDerivedType) { return; }
    writer.writeDateValue("approvedAt", submissionVersionLookup.approvedAt);
    writer.writeGuidValue("id", submissionVersionLookup.id);
    writer.writeBooleanValue("isCurrent", submissionVersionLookup.isCurrent);
    writer.writeDateValue("recordedAt", submissionVersionLookup.recordedAt);
    writer.writeStringValue("validationCode", submissionVersionLookup.validationCode);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param TextFieldMeta The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTextFieldMeta(writer: SerializationWriter, textFieldMeta: Partial<TextFieldMeta> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!textFieldMeta || isSerializingDerivedType) { return; }
    serializeBaseFieldProps(writer, textFieldMeta, isSerializingDerivedType)
    writer.writeStringValue("defaultValue", textFieldMeta.defaultValue);
    writer.writeNumberValue("maxlength", textFieldMeta.maxlength);
    writer.writeNumberValue("minlength", textFieldMeta.minlength);
    writer.writeStringValue("pattern", textFieldMeta.pattern);
    writer.writeEnumValue<TextFieldMeta_type>("type", textFieldMeta.type);
}
export interface SimpleDateFieldMeta extends BaseDateFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: number | null;
    /**
     * The type property
     */
    type?: SimpleDateFieldMeta_type | null;
}
export type SimpleDateFieldMeta_type = (typeof SimpleDateFieldMeta_typeObject)[keyof typeof SimpleDateFieldMeta_typeObject];
export interface SubmissionLookup extends Parsable {
    /**
     * The form property
     */
    form?: string | null;
    /**
     * The formVersion property
     */
    formVersion?: Guid | null;
    /**
     * The index property
     */
    index?: number | null;
    /**
     * The recordedAt property
     */
    recordedAt?: Date | null;
    /**
     * The versions property
     */
    versions?: SubmissionVersionLookup[] | null;
}
/**
 * A single submission response
 */
export interface SubmissionResponse extends Parsable {
    /**
     * UUID of the form field
     */
    fieldId?: Guid | null;
    /**
     * The form identifier/slug
     */
    form?: string | null;
    /**
     * UUID of the form version
     */
    formVersion?: Guid | null;
    /**
     * The index of the submission
     */
    submissionIndex?: number | null;
    /**
     * UUID of the submission version (response_id in database)
     */
    submissionVersionId?: Guid | null;
    /**
     * The response value for the field
     */
    value?: string | null;
}
export interface SubmissionVersionLookup extends Parsable {
    /**
     * The approvedAt property
     */
    approvedAt?: Date | null;
    /**
     * The id property
     */
    id?: Guid | null;
    /**
     * The isCurrent property
     */
    isCurrent?: boolean | null;
    /**
     * The recordedAt property
     */
    recordedAt?: Date | null;
    /**
     * The validationCode property
     */
    validationCode?: string | null;
}
export interface TextFieldMeta extends BaseFieldProps, Parsable {
    /**
     * The defaultValue property
     */
    defaultValue?: string | null;
    /**
     * The maxlength property
     */
    maxlength?: number | null;
    /**
     * The minlength property
     */
    minlength?: number | null;
    /**
     * The pattern property
     */
    pattern?: string | null;
    /**
     * The type property
     */
    type?: TextFieldMeta_type | null;
}
export type TextFieldMeta_type = (typeof TextFieldMeta_typeObject)[keyof typeof TextFieldMeta_typeObject];
export const BooleanFieldMeta_typeObject = {
    Boolean: "boolean",
} as const;
export const DatasetInsert_isNewObject = {
    TrueEscaped: "true",
} as const;
export const DatasetUpdate_isNewObject = {
    FalseEscaped: "false",
} as const;
export const ExistingDatasetItemUpdate_isNewObject = {
    FalseEscaped: "false",
} as const;
export const FormItemField_typeObject = {
    Field: "field",
} as const;
export const FormItemGroup_typeObject = {
    Group: "group",
} as const;
export const FormItemImage_typeObject = {
    Image: "image",
} as const;
export const FormItemNote_typeObject = {
    Note: "note",
} as const;
export const FormItemSeparator_typeObject = {
    Separator: "separator",
} as const;
export const GeoPointFieldMeta_typeObject = {
    GeoPoint: "geo-point",
} as const;
export const MultiDateFieldMeta_typeObject = {
    MultiDate: "multi-date",
} as const;
export const NewDatasetItem_isNewObject = {
    TrueEscaped: "true",
} as const;
export const NumberFieldMeta_typeObject = {
    Integer: "integer",
    Float: "float",
} as const;
export const RangeDateFieldMeta_typeObject = {
    DateRange: "date-range",
} as const;
export const RelevanceCondition_operatorObject = {
    And: "and",
    Or: "or",
} as const;
export const RelevanceLogicExpressionOperatorObject = {
    InEscaped: "in",
    Eq: "eq",
    Ne: "ne",
    Gt: "gt",
    Lt: "lt",
    Lte: "lte",
    Gte: "gte",
    Empty: "empty",
    Between: "between",
    Match: "match",
    IsNull: "isNull",
    IsNotNull: "isNotNull",
    Checked: "checked",
    Unchecked: "unchecked",
    SelectedAny: "selectedAny",
    SelectedAll: "selectedAll",
    Noselection: "noselection",
    Before: "before",
    After: "after",
    AfterOrOn: "afterOrOn",
    BeforeOrOn: "beforeOrOn",
} as const;
export const SelectFieldMeta_typeObject = {
    SingleSelect: "single-select",
    MultiSelect: "multi-select",
} as const;
export const SeparatorItemMeta_orientationObject = {
    Vertical: "vertical",
    Horizontal: "horizontal",
} as const;
export const SimpleDateFieldMeta_typeObject = {
    Date: "date",
    DateTime: "date-time",
} as const;
export const TextFieldMeta_typeObject = {
    Text: "text",
    Multiline: "multiline",
} as const;
/* tslint:enable */
/* eslint-enable */
